# **********************************************************************
#
# Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
#
# This copy of Ice is licensed to you under the terms described in the
# ICE_LICENSE file included in this distribution.
#
# **********************************************************************
#
# Ice version 3.5.1
#
# <auto-generated>
#
# Generated from file `IceStorm.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

import Ice, IcePy
import Ice_Identity_ice
import Ice_SliceChecksumDict_ice
import IceStorm_Metrics_ice

# Included module Ice
_M_Ice = Ice.openModule('Ice')

# Included module IceMX
_M_IceMX = Ice.openModule('IceMX')

# Start of module IceStorm
_M_IceStorm = Ice.openModule('IceStorm')
__name__ = 'IceStorm'
_M_IceStorm.__doc__ = '''A messaging service with support for federation. In contrast to
most other messaging or event services, IceStorm supports typed
events, meaning that broadcasting a message over a federation is as
easy as invoking a method on an interface.'''

if 'Topic' not in _M_IceStorm.__dict__:
    _M_IceStorm._t_Topic = IcePy.declareClass('::IceStorm::Topic')
    _M_IceStorm._t_TopicPrx = IcePy.declareProxy('::IceStorm::Topic')

if 'LinkInfo' not in _M_IceStorm.__dict__:
    _M_IceStorm.LinkInfo = Ice.createTempClass()
    class LinkInfo(object):
        '''Information on the topic links.'''
        def __init__(self, theTopic=None, name='', cost=0):
            self.theTopic = theTopic
            self.name = name
            self.cost = cost

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_IceStorm.LinkInfo):
                return NotImplemented
            else:
                if self.theTopic != other.theTopic:
                    return False
                if self.name != other.name:
                    return False
                if self.cost != other.cost:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_IceStorm._t_LinkInfo)

        __repr__ = __str__

    _M_IceStorm._t_LinkInfo = IcePy.defineStruct('::IceStorm::LinkInfo', LinkInfo, (), (
        ('theTopic', (), _M_IceStorm._t_TopicPrx),
        ('name', (), IcePy._t_string),
        ('cost', (), IcePy._t_int)
    ))

    _M_IceStorm.LinkInfo = LinkInfo
    del LinkInfo

if '_t_LinkInfoSeq' not in _M_IceStorm.__dict__:
    _M_IceStorm._t_LinkInfoSeq = IcePy.defineSequence('::IceStorm::LinkInfoSeq', (), _M_IceStorm._t_LinkInfo)

if '_t_QoS' not in _M_IceStorm.__dict__:
    _M_IceStorm._t_QoS = IcePy.defineDictionary('::IceStorm::QoS', (), IcePy._t_string, IcePy._t_string)

if 'LinkExists' not in _M_IceStorm.__dict__:
    _M_IceStorm.LinkExists = Ice.createTempClass()
    class LinkExists(Ice.UserException):
        '''This exception indicates that an attempt was made to create a link
that already exists.'''
        def __init__(self, name=''):
            self.name = name

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'IceStorm::LinkExists'

    _M_IceStorm._t_LinkExists = IcePy.defineException('::IceStorm::LinkExists', LinkExists, (), False, None, (('name', (), IcePy._t_string, False, 0),))
    LinkExists._ice_type = _M_IceStorm._t_LinkExists

    _M_IceStorm.LinkExists = LinkExists
    del LinkExists

if 'NoSuchLink' not in _M_IceStorm.__dict__:
    _M_IceStorm.NoSuchLink = Ice.createTempClass()
    class NoSuchLink(Ice.UserException):
        '''This exception indicates that an attempt was made to remove a
link that does not exist.'''
        def __init__(self, name=''):
            self.name = name

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'IceStorm::NoSuchLink'

    _M_IceStorm._t_NoSuchLink = IcePy.defineException('::IceStorm::NoSuchLink', NoSuchLink, (), False, None, (('name', (), IcePy._t_string, False, 0),))
    NoSuchLink._ice_type = _M_IceStorm._t_NoSuchLink

    _M_IceStorm.NoSuchLink = NoSuchLink
    del NoSuchLink

if 'AlreadySubscribed' not in _M_IceStorm.__dict__:
    _M_IceStorm.AlreadySubscribed = Ice.createTempClass()
    class AlreadySubscribed(Ice.UserException):
        '''This exception indicates that an attempt was made to subscribe
a proxy for which a subscription already exists.'''
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'IceStorm::AlreadySubscribed'

    _M_IceStorm._t_AlreadySubscribed = IcePy.defineException('::IceStorm::AlreadySubscribed', AlreadySubscribed, (), False, None, ())
    AlreadySubscribed._ice_type = _M_IceStorm._t_AlreadySubscribed

    _M_IceStorm.AlreadySubscribed = AlreadySubscribed
    del AlreadySubscribed

if 'BadQoS' not in _M_IceStorm.__dict__:
    _M_IceStorm.BadQoS = Ice.createTempClass()
    class BadQoS(Ice.UserException):
        '''This exception indicates that a subscription failed due to an
invalid QoS.'''
        def __init__(self, reason=''):
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'IceStorm::BadQoS'

    _M_IceStorm._t_BadQoS = IcePy.defineException('::IceStorm::BadQoS', BadQoS, (), False, None, (('reason', (), IcePy._t_string, False, 0),))
    BadQoS._ice_type = _M_IceStorm._t_BadQoS

    _M_IceStorm.BadQoS = BadQoS
    del BadQoS

if 'Topic' not in _M_IceStorm.__dict__:
    _M_IceStorm.Topic = Ice.createTempClass()
    class Topic(Ice.Object):
        '''Publishers publish information on a particular topic. A topic
logically represents a type.'''
        def __init__(self):
            if Ice.getType(self) == _M_IceStorm.Topic:
                raise RuntimeError('IceStorm.Topic is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::IceStorm::Topic')

        def ice_id(self, current=None):
            return '::IceStorm::Topic'

        def ice_staticId():
            return '::IceStorm::Topic'
        ice_staticId = staticmethod(ice_staticId)

        def getName(self, current=None):
            '''Get the name of this topic.

Returns:
    The name of the topic.'''
            pass

        def getPublisher(self, current=None):
            '''Get a proxy to a publisher object for this topic. To publish
data to a topic, the publisher calls getPublisher and then
casts to the topic type. An unchecked cast must be used on this
proxy. If a replicated IceStorm deployment is used this call
may return a replicated proxy.

Returns:
    A proxy to publish data on this topic.'''
            pass

        def getNonReplicatedPublisher(self, current=None):
            '''Get a non-replicated proxy to a publisher object for this
topic. To publish data to a topic, the publisher calls
getPublisher and then casts to the topic type. An unchecked
cast must be used on this proxy.

Returns:
    A proxy to publish data on this topic.'''
            pass

        def subscribe(self, theQoS, subscriber, current=None):
            '''Subscribe with the given qos to this topic. If the given
subscriber proxy has already been registered, it will be
replaced. Note that this can cause a loss of events to the
subscribed object.

This operation is deprecated as of version 3.2.

Arguments:
    theQoS The quality of service parameters for this
subscription.

    subscriber The subscriber's proxy.

Returns:
    The per-subscriber publisher object.'''
            pass

        def subscribeAndGetPublisher(self, theQoS, subscriber, current=None):
            '''Subscribe with the given qos to this topic.  A
per-subscriber publisher object is returned.

Arguments:
    theQoS The quality of service parameters for this
subscription.

    subscriber The subscriber's proxy.

Returns:
    The per-subscriber publisher object.

Exceptions:
    AlreadySubscribed Raised if the subscriber object is
already subscribed.

    BadQoS Raised if the requested quality of service
is unavailable or invalid.'''
            pass

        def unsubscribe(self, subscriber, current=None):
            '''Unsubscribe the given subscriber.

Arguments:
    subscriber The proxy of an existing subscriber.'''
            pass

        def link(self, linkTo, cost, current=None):
            '''Create a link to the given topic. All events originating
on this topic will also be sent to linkTo.

Arguments:
    linkTo The topic to link to.

    cost The cost to the linked topic.

Exceptions:
    LinkExists Raised if a link to the same topic already
exists.'''
            pass

        def unlink(self, linkTo, current=None):
            '''Destroy the link from this topic to the given topic linkTo.

Arguments:
    linkTo The topic to destroy the link to.

Exceptions:
    NoSuchLink Raised if a link to the topic does not exist.'''
            pass

        def getLinkInfoSeq(self, current=None):
            '''Retrieve information on the current links.

Returns:
    A sequence of LinkInfo objects.'''
            pass

        def getSubscribers(self, current=None):
            '''Retrieve the list of subscribers for this topic.

Returns:
    The sequence of Ice identities for the subscriber objects.'''
            pass

        def destroy(self, current=None):
            '''Destroy the topic.'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_IceStorm._t_Topic)

        __repr__ = __str__

    _M_IceStorm.TopicPrx = Ice.createTempClass()
    class TopicPrx(Ice.ObjectPrx):

        '''Get the name of this topic.

Returns:
    The name of the topic.'''
        def getName(self, _ctx=None):
            return _M_IceStorm.Topic._op_getName.invoke(self, ((), _ctx))

        '''Get the name of this topic.

Returns:
    The name of the topic.'''
        def begin_getName(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.Topic._op_getName.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Get the name of this topic.

Returns:
    The name of the topic.'''
        def end_getName(self, _r):
            return _M_IceStorm.Topic._op_getName.end(self, _r)

        '''Get a proxy to a publisher object for this topic. To publish
data to a topic, the publisher calls getPublisher and then
casts to the topic type. An unchecked cast must be used on this
proxy. If a replicated IceStorm deployment is used this call
may return a replicated proxy.

Returns:
    A proxy to publish data on this topic.'''
        def getPublisher(self, _ctx=None):
            return _M_IceStorm.Topic._op_getPublisher.invoke(self, ((), _ctx))

        '''Get a proxy to a publisher object for this topic. To publish
data to a topic, the publisher calls getPublisher and then
casts to the topic type. An unchecked cast must be used on this
proxy. If a replicated IceStorm deployment is used this call
may return a replicated proxy.

Returns:
    A proxy to publish data on this topic.'''
        def begin_getPublisher(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.Topic._op_getPublisher.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Get a proxy to a publisher object for this topic. To publish
data to a topic, the publisher calls getPublisher and then
casts to the topic type. An unchecked cast must be used on this
proxy. If a replicated IceStorm deployment is used this call
may return a replicated proxy.

Returns:
    A proxy to publish data on this topic.'''
        def end_getPublisher(self, _r):
            return _M_IceStorm.Topic._op_getPublisher.end(self, _r)

        '''Get a non-replicated proxy to a publisher object for this
topic. To publish data to a topic, the publisher calls
getPublisher and then casts to the topic type. An unchecked
cast must be used on this proxy.

Returns:
    A proxy to publish data on this topic.'''
        def getNonReplicatedPublisher(self, _ctx=None):
            return _M_IceStorm.Topic._op_getNonReplicatedPublisher.invoke(self, ((), _ctx))

        '''Get a non-replicated proxy to a publisher object for this
topic. To publish data to a topic, the publisher calls
getPublisher and then casts to the topic type. An unchecked
cast must be used on this proxy.

Returns:
    A proxy to publish data on this topic.'''
        def begin_getNonReplicatedPublisher(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.Topic._op_getNonReplicatedPublisher.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Get a non-replicated proxy to a publisher object for this
topic. To publish data to a topic, the publisher calls
getPublisher and then casts to the topic type. An unchecked
cast must be used on this proxy.

Returns:
    A proxy to publish data on this topic.'''
        def end_getNonReplicatedPublisher(self, _r):
            return _M_IceStorm.Topic._op_getNonReplicatedPublisher.end(self, _r)

        '''Subscribe with the given qos to this topic. If the given
subscriber proxy has already been registered, it will be
replaced. Note that this can cause a loss of events to the
subscribed object.

This operation is deprecated as of version 3.2.

Arguments:
    theQoS The quality of service parameters for this
subscription.

    subscriber The subscriber's proxy.

Returns:
    The per-subscriber publisher object.'''
        def subscribe(self, theQoS, subscriber, _ctx=None):
            return _M_IceStorm.Topic._op_subscribe.invoke(self, ((theQoS, subscriber), _ctx))

        '''Subscribe with the given qos to this topic. If the given
subscriber proxy has already been registered, it will be
replaced. Note that this can cause a loss of events to the
subscribed object.

This operation is deprecated as of version 3.2.

Arguments:
    theQoS The quality of service parameters for this
subscription.

    subscriber The subscriber's proxy.

Returns:
    The per-subscriber publisher object.'''
        def begin_subscribe(self, theQoS, subscriber, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.Topic._op_subscribe.begin(self, ((theQoS, subscriber), _response, _ex, _sent, _ctx))

        '''Subscribe with the given qos to this topic. If the given
subscriber proxy has already been registered, it will be
replaced. Note that this can cause a loss of events to the
subscribed object.

This operation is deprecated as of version 3.2.

Arguments:
    theQoS The quality of service parameters for this
subscription.

    subscriber The subscriber's proxy.

Returns:
    The per-subscriber publisher object.'''
        def end_subscribe(self, _r):
            return _M_IceStorm.Topic._op_subscribe.end(self, _r)

        '''Subscribe with the given qos to this topic.  A
per-subscriber publisher object is returned.

Arguments:
    theQoS The quality of service parameters for this
subscription.

    subscriber The subscriber's proxy.

Returns:
    The per-subscriber publisher object.

Exceptions:
    AlreadySubscribed Raised if the subscriber object is
already subscribed.

    BadQoS Raised if the requested quality of service
is unavailable or invalid.'''
        def subscribeAndGetPublisher(self, theQoS, subscriber, _ctx=None):
            return _M_IceStorm.Topic._op_subscribeAndGetPublisher.invoke(self, ((theQoS, subscriber), _ctx))

        '''Subscribe with the given qos to this topic.  A
per-subscriber publisher object is returned.

Arguments:
    theQoS The quality of service parameters for this
subscription.

    subscriber The subscriber's proxy.

Returns:
    The per-subscriber publisher object.

Exceptions:
    AlreadySubscribed Raised if the subscriber object is
already subscribed.

    BadQoS Raised if the requested quality of service
is unavailable or invalid.'''
        def begin_subscribeAndGetPublisher(self, theQoS, subscriber, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.Topic._op_subscribeAndGetPublisher.begin(self, ((theQoS, subscriber), _response, _ex, _sent, _ctx))

        '''Subscribe with the given qos to this topic.  A
per-subscriber publisher object is returned.

Arguments:
    theQoS The quality of service parameters for this
subscription.

    subscriber The subscriber's proxy.

Returns:
    The per-subscriber publisher object.

Exceptions:
    AlreadySubscribed Raised if the subscriber object is
already subscribed.

    BadQoS Raised if the requested quality of service
is unavailable or invalid.'''
        def end_subscribeAndGetPublisher(self, _r):
            return _M_IceStorm.Topic._op_subscribeAndGetPublisher.end(self, _r)

        '''Unsubscribe the given subscriber.

Arguments:
    subscriber The proxy of an existing subscriber.'''
        def unsubscribe(self, subscriber, _ctx=None):
            return _M_IceStorm.Topic._op_unsubscribe.invoke(self, ((subscriber, ), _ctx))

        '''Unsubscribe the given subscriber.

Arguments:
    subscriber The proxy of an existing subscriber.'''
        def begin_unsubscribe(self, subscriber, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.Topic._op_unsubscribe.begin(self, ((subscriber, ), _response, _ex, _sent, _ctx))

        '''Unsubscribe the given subscriber.

Arguments:
    subscriber The proxy of an existing subscriber.'''
        def end_unsubscribe(self, _r):
            return _M_IceStorm.Topic._op_unsubscribe.end(self, _r)

        '''Create a link to the given topic. All events originating
on this topic will also be sent to linkTo.

Arguments:
    linkTo The topic to link to.

    cost The cost to the linked topic.

Exceptions:
    LinkExists Raised if a link to the same topic already
exists.'''
        def link(self, linkTo, cost, _ctx=None):
            return _M_IceStorm.Topic._op_link.invoke(self, ((linkTo, cost), _ctx))

        '''Create a link to the given topic. All events originating
on this topic will also be sent to linkTo.

Arguments:
    linkTo The topic to link to.

    cost The cost to the linked topic.

Exceptions:
    LinkExists Raised if a link to the same topic already
exists.'''
        def begin_link(self, linkTo, cost, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.Topic._op_link.begin(self, ((linkTo, cost), _response, _ex, _sent, _ctx))

        '''Create a link to the given topic. All events originating
on this topic will also be sent to linkTo.

Arguments:
    linkTo The topic to link to.

    cost The cost to the linked topic.

Exceptions:
    LinkExists Raised if a link to the same topic already
exists.'''
        def end_link(self, _r):
            return _M_IceStorm.Topic._op_link.end(self, _r)

        '''Destroy the link from this topic to the given topic linkTo.

Arguments:
    linkTo The topic to destroy the link to.

Exceptions:
    NoSuchLink Raised if a link to the topic does not exist.'''
        def unlink(self, linkTo, _ctx=None):
            return _M_IceStorm.Topic._op_unlink.invoke(self, ((linkTo, ), _ctx))

        '''Destroy the link from this topic to the given topic linkTo.

Arguments:
    linkTo The topic to destroy the link to.

Exceptions:
    NoSuchLink Raised if a link to the topic does not exist.'''
        def begin_unlink(self, linkTo, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.Topic._op_unlink.begin(self, ((linkTo, ), _response, _ex, _sent, _ctx))

        '''Destroy the link from this topic to the given topic linkTo.

Arguments:
    linkTo The topic to destroy the link to.

Exceptions:
    NoSuchLink Raised if a link to the topic does not exist.'''
        def end_unlink(self, _r):
            return _M_IceStorm.Topic._op_unlink.end(self, _r)

        '''Retrieve information on the current links.

Returns:
    A sequence of LinkInfo objects.'''
        def getLinkInfoSeq(self, _ctx=None):
            return _M_IceStorm.Topic._op_getLinkInfoSeq.invoke(self, ((), _ctx))

        '''Retrieve information on the current links.

Returns:
    A sequence of LinkInfo objects.'''
        def begin_getLinkInfoSeq(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.Topic._op_getLinkInfoSeq.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Retrieve information on the current links.

Returns:
    A sequence of LinkInfo objects.'''
        def end_getLinkInfoSeq(self, _r):
            return _M_IceStorm.Topic._op_getLinkInfoSeq.end(self, _r)

        '''Retrieve the list of subscribers for this topic.

Returns:
    The sequence of Ice identities for the subscriber objects.'''
        def getSubscribers(self, _ctx=None):
            return _M_IceStorm.Topic._op_getSubscribers.invoke(self, ((), _ctx))

        '''Retrieve the list of subscribers for this topic.

Returns:
    The sequence of Ice identities for the subscriber objects.'''
        def begin_getSubscribers(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.Topic._op_getSubscribers.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Retrieve the list of subscribers for this topic.

Returns:
    The sequence of Ice identities for the subscriber objects.'''
        def end_getSubscribers(self, _r):
            return _M_IceStorm.Topic._op_getSubscribers.end(self, _r)

        '''Destroy the topic.'''
        def destroy(self, _ctx=None):
            return _M_IceStorm.Topic._op_destroy.invoke(self, ((), _ctx))

        '''Destroy the topic.'''
        def begin_destroy(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.Topic._op_destroy.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Destroy the topic.'''
        def end_destroy(self, _r):
            return _M_IceStorm.Topic._op_destroy.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_IceStorm.TopicPrx.ice_checkedCast(proxy, '::IceStorm::Topic', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_IceStorm.TopicPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_IceStorm._t_TopicPrx = IcePy.defineProxy('::IceStorm::Topic', TopicPrx)

    _M_IceStorm._t_Topic = IcePy.defineClass('::IceStorm::Topic', Topic, -1, (), True, False, None, (), ())
    Topic._ice_type = _M_IceStorm._t_Topic

    Topic._op_getName = IcePy.Operation('getName', Ice.OperationMode.Idempotent, Ice.OperationMode.Nonmutating, False, None, (), (), (), ((), IcePy._t_string, False, 0), ())
    Topic._op_getPublisher = IcePy.Operation('getPublisher', Ice.OperationMode.Idempotent, Ice.OperationMode.Nonmutating, False, None, (), (), (), ((), IcePy._t_ObjectPrx, False, 0), ())
    Topic._op_getNonReplicatedPublisher = IcePy.Operation('getNonReplicatedPublisher', Ice.OperationMode.Idempotent, Ice.OperationMode.Nonmutating, False, None, (), (), (), ((), IcePy._t_ObjectPrx, False, 0), ())
    Topic._op_subscribe = IcePy.Operation('subscribe', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_IceStorm._t_QoS, False, 0), ((), IcePy._t_ObjectPrx, False, 0)), (), None, ())
    Topic._op_subscribe.deprecate("subscribe is deprecated, use subscribeAndGetPublisher instead")
    Topic._op_subscribeAndGetPublisher = IcePy.Operation('subscribeAndGetPublisher', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_IceStorm._t_QoS, False, 0), ((), IcePy._t_ObjectPrx, False, 0)), (), ((), IcePy._t_ObjectPrx, False, 0), (_M_IceStorm._t_AlreadySubscribed, _M_IceStorm._t_BadQoS))
    Topic._op_unsubscribe = IcePy.Operation('unsubscribe', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_ObjectPrx, False, 0),), (), None, ())
    Topic._op_link = IcePy.Operation('link', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_IceStorm._t_TopicPrx, False, 0), ((), IcePy._t_int, False, 0)), (), None, (_M_IceStorm._t_LinkExists,))
    Topic._op_unlink = IcePy.Operation('unlink', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_IceStorm._t_TopicPrx, False, 0),), (), None, (_M_IceStorm._t_NoSuchLink,))
    Topic._op_getLinkInfoSeq = IcePy.Operation('getLinkInfoSeq', Ice.OperationMode.Idempotent, Ice.OperationMode.Nonmutating, False, None, (), (), (), ((), _M_IceStorm._t_LinkInfoSeq, False, 0), ())
    Topic._op_getSubscribers = IcePy.Operation('getSubscribers', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_Ice._t_IdentitySeq, False, 0), ())
    Topic._op_destroy = IcePy.Operation('destroy', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())

    _M_IceStorm.Topic = Topic
    del Topic

    _M_IceStorm.TopicPrx = TopicPrx
    del TopicPrx

if '_t_TopicDict' not in _M_IceStorm.__dict__:
    _M_IceStorm._t_TopicDict = IcePy.defineDictionary('::IceStorm::TopicDict', (), IcePy._t_string, _M_IceStorm._t_TopicPrx)

if 'TopicExists' not in _M_IceStorm.__dict__:
    _M_IceStorm.TopicExists = Ice.createTempClass()
    class TopicExists(Ice.UserException):
        '''This exception indicates that an attempt was made to create a topic
that already exists.'''
        def __init__(self, name=''):
            self.name = name

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'IceStorm::TopicExists'

    _M_IceStorm._t_TopicExists = IcePy.defineException('::IceStorm::TopicExists', TopicExists, (), False, None, (('name', (), IcePy._t_string, False, 0),))
    TopicExists._ice_type = _M_IceStorm._t_TopicExists

    _M_IceStorm.TopicExists = TopicExists
    del TopicExists

if 'NoSuchTopic' not in _M_IceStorm.__dict__:
    _M_IceStorm.NoSuchTopic = Ice.createTempClass()
    class NoSuchTopic(Ice.UserException):
        '''This exception indicates that an attempt was made to retrieve a
topic that does not exist.'''
        def __init__(self, name=''):
            self.name = name

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_name = 'IceStorm::NoSuchTopic'

    _M_IceStorm._t_NoSuchTopic = IcePy.defineException('::IceStorm::NoSuchTopic', NoSuchTopic, (), False, None, (('name', (), IcePy._t_string, False, 0),))
    NoSuchTopic._ice_type = _M_IceStorm._t_NoSuchTopic

    _M_IceStorm.NoSuchTopic = NoSuchTopic
    del NoSuchTopic

if 'TopicManager' not in _M_IceStorm.__dict__:
    _M_IceStorm.TopicManager = Ice.createTempClass()
    class TopicManager(Ice.Object):
        '''A topic manager manages topics, and subscribers to topics.'''
        def __init__(self):
            if Ice.getType(self) == _M_IceStorm.TopicManager:
                raise RuntimeError('IceStorm.TopicManager is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::IceStorm::TopicManager')

        def ice_id(self, current=None):
            return '::IceStorm::TopicManager'

        def ice_staticId():
            return '::IceStorm::TopicManager'
        ice_staticId = staticmethod(ice_staticId)

        def create(self, name, current=None):
            '''Create a new topic. The topic name must be unique, otherwise
TopicExists is raised.

Arguments:
    name The name of the topic.

Returns:
    A proxy to the topic instance.

Exceptions:
    TopicExists Raised if a topic with the same name already
exists.'''
            pass

        def retrieve(self, name, current=None):
            '''Retrieve a topic by name.

Arguments:
    name The name of the topic.

Returns:
    A proxy to the topic instance.

Exceptions:
    NoSuchTopic Raised if the topic does not exist.'''
            pass

        def retrieveAll(self, current=None):
            '''Retrieve all topics managed by this topic manager.

Returns:
    A dictionary of string, topic proxy pairs.'''
            pass

        def getSliceChecksums(self, current=None):
            '''Returns the checksums for the IceStorm Slice definitions.

Returns:
    A dictionary mapping Slice type ids to their checksums.'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_IceStorm._t_TopicManager)

        __repr__ = __str__

    _M_IceStorm.TopicManagerPrx = Ice.createTempClass()
    class TopicManagerPrx(Ice.ObjectPrx):

        '''Create a new topic. The topic name must be unique, otherwise
TopicExists is raised.

Arguments:
    name The name of the topic.

Returns:
    A proxy to the topic instance.

Exceptions:
    TopicExists Raised if a topic with the same name already
exists.'''
        def create(self, name, _ctx=None):
            return _M_IceStorm.TopicManager._op_create.invoke(self, ((name, ), _ctx))

        '''Create a new topic. The topic name must be unique, otherwise
TopicExists is raised.

Arguments:
    name The name of the topic.

Returns:
    A proxy to the topic instance.

Exceptions:
    TopicExists Raised if a topic with the same name already
exists.'''
        def begin_create(self, name, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.TopicManager._op_create.begin(self, ((name, ), _response, _ex, _sent, _ctx))

        '''Create a new topic. The topic name must be unique, otherwise
TopicExists is raised.

Arguments:
    name The name of the topic.

Returns:
    A proxy to the topic instance.

Exceptions:
    TopicExists Raised if a topic with the same name already
exists.'''
        def end_create(self, _r):
            return _M_IceStorm.TopicManager._op_create.end(self, _r)

        '''Retrieve a topic by name.

Arguments:
    name The name of the topic.

Returns:
    A proxy to the topic instance.

Exceptions:
    NoSuchTopic Raised if the topic does not exist.'''
        def retrieve(self, name, _ctx=None):
            return _M_IceStorm.TopicManager._op_retrieve.invoke(self, ((name, ), _ctx))

        '''Retrieve a topic by name.

Arguments:
    name The name of the topic.

Returns:
    A proxy to the topic instance.

Exceptions:
    NoSuchTopic Raised if the topic does not exist.'''
        def begin_retrieve(self, name, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.TopicManager._op_retrieve.begin(self, ((name, ), _response, _ex, _sent, _ctx))

        '''Retrieve a topic by name.

Arguments:
    name The name of the topic.

Returns:
    A proxy to the topic instance.

Exceptions:
    NoSuchTopic Raised if the topic does not exist.'''
        def end_retrieve(self, _r):
            return _M_IceStorm.TopicManager._op_retrieve.end(self, _r)

        '''Retrieve all topics managed by this topic manager.

Returns:
    A dictionary of string, topic proxy pairs.'''
        def retrieveAll(self, _ctx=None):
            return _M_IceStorm.TopicManager._op_retrieveAll.invoke(self, ((), _ctx))

        '''Retrieve all topics managed by this topic manager.

Returns:
    A dictionary of string, topic proxy pairs.'''
        def begin_retrieveAll(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.TopicManager._op_retrieveAll.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Retrieve all topics managed by this topic manager.

Returns:
    A dictionary of string, topic proxy pairs.'''
        def end_retrieveAll(self, _r):
            return _M_IceStorm.TopicManager._op_retrieveAll.end(self, _r)

        '''Returns the checksums for the IceStorm Slice definitions.

Returns:
    A dictionary mapping Slice type ids to their checksums.'''
        def getSliceChecksums(self, _ctx=None):
            return _M_IceStorm.TopicManager._op_getSliceChecksums.invoke(self, ((), _ctx))

        '''Returns the checksums for the IceStorm Slice definitions.

Returns:
    A dictionary mapping Slice type ids to their checksums.'''
        def begin_getSliceChecksums(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IceStorm.TopicManager._op_getSliceChecksums.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Returns the checksums for the IceStorm Slice definitions.

Returns:
    A dictionary mapping Slice type ids to their checksums.'''
        def end_getSliceChecksums(self, _r):
            return _M_IceStorm.TopicManager._op_getSliceChecksums.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_IceStorm.TopicManagerPrx.ice_checkedCast(proxy, '::IceStorm::TopicManager', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_IceStorm.TopicManagerPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_IceStorm._t_TopicManagerPrx = IcePy.defineProxy('::IceStorm::TopicManager', TopicManagerPrx)

    _M_IceStorm._t_TopicManager = IcePy.defineClass('::IceStorm::TopicManager', TopicManager, -1, (), True, False, None, (), ())
    TopicManager._ice_type = _M_IceStorm._t_TopicManager

    TopicManager._op_create = IcePy.Operation('create', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_string, False, 0),), (), ((), _M_IceStorm._t_TopicPrx, False, 0), (_M_IceStorm._t_TopicExists,))
    TopicManager._op_retrieve = IcePy.Operation('retrieve', Ice.OperationMode.Idempotent, Ice.OperationMode.Nonmutating, False, None, (), (((), IcePy._t_string, False, 0),), (), ((), _M_IceStorm._t_TopicPrx, False, 0), (_M_IceStorm._t_NoSuchTopic,))
    TopicManager._op_retrieveAll = IcePy.Operation('retrieveAll', Ice.OperationMode.Idempotent, Ice.OperationMode.Nonmutating, False, None, (), (), (), ((), _M_IceStorm._t_TopicDict, False, 0), ())
    TopicManager._op_getSliceChecksums = IcePy.Operation('getSliceChecksums', Ice.OperationMode.Idempotent, Ice.OperationMode.Nonmutating, False, None, (), (), (), ((), _M_Ice._t_SliceChecksumDict, False, 0), ())

    _M_IceStorm.TopicManager = TopicManager
    del TopicManager

    _M_IceStorm.TopicManagerPrx = TopicManagerPrx
    del TopicManagerPrx

# End of module IceStorm

Ice.sliceChecksums["::IceStorm::AlreadySubscribed"] = "5a82e77b38f02f3118c536f9446a889e"
Ice.sliceChecksums["::IceStorm::BadQoS"] = "44f2de592dd62e3f7f4ffdf043692d"
Ice.sliceChecksums["::IceStorm::LinkExists"] = "e11768febd56a8813729ce69be6c4c2"
Ice.sliceChecksums["::IceStorm::LinkInfo"] = "d0e073e5e0925ec95656f71d572e2e13"
Ice.sliceChecksums["::IceStorm::LinkInfoSeq"] = "a8921e43838692bbe6ca63f3dcf9b6"
Ice.sliceChecksums["::IceStorm::NoSuchLink"] = "fd8f652776796bffca2df1a3baf455a3"
Ice.sliceChecksums["::IceStorm::NoSuchTopic"] = "7a9479a5c39cdd32335d722bbc971176"
Ice.sliceChecksums["::IceStorm::QoS"] = "3e27cb32bc95cca7b013efbf5c254b35"
Ice.sliceChecksums["::IceStorm::Topic"] = "8d43d11b24e2f41378faab0c9819e86"
Ice.sliceChecksums["::IceStorm::TopicDict"] = "fff078a98be068c52d9e1d7d8f6df2a"
Ice.sliceChecksums["::IceStorm::TopicExists"] = "38e6913833539b8d616d114d4e7b28d"
Ice.sliceChecksums["::IceStorm::TopicManager"] = "ffc1baf19222891f8b432be6551fed5"
